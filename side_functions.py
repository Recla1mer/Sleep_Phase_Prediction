"""
Author: Johannes Peter Knoll

In this file we provide functions that are used to keep the code a little bit cleaner.
"""

# IMPORTS
import time
import numpy as np
import os
import shutil


"""
=============================
Printing Progress to console
=============================
"""


def print_smart_float(floating_point_number: float, decimals: int) -> str:
    """
    Convert a floating point number to a string with a certain number of decimals.

    ARGUMENTS:
    ------------------------------
    floating_point_number: float
        the number to convert
    decimals: int
        the number of decimals to keep
    
    RETURNS:
    ------------------------------
    str
        the number as a string with the specified number of decimals
    """

    count_division_by_10 = 0
    while True:
        if floating_point_number < 10:
            break
        else:
            floating_point_number /= 10
            count_division_by_10 += 1
    
    count_multiply_by_10 = 0
    if count_division_by_10 == 0:
        while True:
            if floating_point_number >= 1:
                break
            else:
                floating_point_number *= 10
                count_multiply_by_10 += 1
    
    floating_point_number = round(floating_point_number, decimals)

    if count_division_by_10 > 0:
        return str(floating_point_number) + " e" + str(count_division_by_10)
    elif count_multiply_by_10 > 0:
        return str(floating_point_number) + " e-" + str(count_multiply_by_10)
    else:
        return str(floating_point_number)


def print_smart_time(time_seconds: float) -> str:
    """
    Convert seconds to a time format that is easier to read.

    ARGUMENTS:
    ------------------------------
    time_seconds: int
        time in seconds
    
    RETURNS:
    ------------------------------
    str
        time in a more readable format
    """

    if time_seconds <= 1:
        return str(round(time_seconds, 1)) + "s"
    else:
        time_seconds = round(time_seconds)
        days = time_seconds // 86400
        if days > 0:
            time_seconds = time_seconds % 86400
        hours = time_seconds // 3600
        if hours > 0:
            time_seconds = time_seconds % 3600
        minutes = time_seconds // 60
        seconds = time_seconds % 60

        if days > 0:
            return str(days) + "d " + str(hours) + "h"
        if hours > 0:
            return str(hours) + "h " + str(minutes) + "m"
        elif minutes > 0:
            return str(minutes) + "m " + str(seconds) + "s"
        else:
            return str(seconds) + "s"


def progress_bar(
        index: int, 
        total: int, 
        start_time: float, 
        previous_length: int = 0, 
        batch_size: int = 1, 
        additional_info: str = ""
    ):
    """
    Prints a progress bar to the console.

    Idea taken from:
    https://stackoverflow.com/questions/6169217/replace-console-output-in-python

    ARGUMENTS:
    ------------------------------
    index: int
        current index
    total: int
        total number
    start_time: float
        time when the process started
    previous_length: int
        length of the previous message generated by this function
    batch_size: int
        Important if Index is increased by more than 1 (e.g. in a batch)
    additional_info: str
        additional information to print at the end of the progress bar
    

    RETURNS:
    ------------------------------
    current_length: int
        length of the current message generated by this function
    """

    if total == 0:
        return

    # estimate time remaining
    if index == 0:
        time_message = ''
    else:
        time_passed = time.time() - start_time
        time_per_index = time_passed/index
        time_total = time_per_index*total
        time_remaining = time_per_index*(total-index)
        time_per_index *= batch_size

        time_passed_str = print_smart_time(time_passed)
        time_per_index_str = print_smart_time(time_per_index)
        time_remaining_str = print_smart_time(time_remaining)
        time_total_str = print_smart_time(time_total)

        time_message = f' | {time_passed_str} / {time_total_str} ({time_per_index_str}/it)'
    
    # get terminal length
    terminal_size = shutil.get_terminal_size((80, 20))
    terminal_length = terminal_size.columns

    # calculate percentage done
    percent_done = index/total*100
    rounded_percent_done = round(percent_done, 1)

    basic_message = f'   ⏳: {rounded_percent_done}%'
    done_message = f' {index} / {total}'
    additional_message = f' | {additional_info}'

    # evaluate bar length
    remaining_length = terminal_length - len(basic_message) - 3 - len(done_message) - len(time_message) - len(additional_message)
    bar_length = remaining_length
    if remaining_length < 0:
        bar_length = 0

    # build done and to-go part of the bar
    done = round(percent_done/100*bar_length)
    togo = bar_length-done

    done_str = '█'*int(done)
    togo_str = '░'*int(togo)

    # based upon available length, decide what to print
    if remaining_length >= 0:
        message = basic_message + f' [{done_str}{togo_str}]' + done_message + time_message + additional_message
    elif remaining_length + len(additional_message) >= 0:
        message = basic_message + ' []' + done_message + time_message
    elif remaining_length + len(additional_message) + len(done_message) >= 0:
        message = basic_message + ' []' + time_message
    else:
        message = basic_message
    
    current_length = len(message)
    buffer_length = max(previous_length - current_length,0)

    print(message + " "*buffer_length, end='\r')

    if index >= total:
        print('   ✅')
    
    return current_length

    # Loss: {print_smart_float(loss, decimals)} | Acc: {round(corr_prop*100, 2)}%'


"""
===============
Override Files
===============
"""


def ask_to_override_files(file_paths: list):
    """
    Asks the user if they want to override files.

    ARGUMENTS:
    ------------------------------
    file_paths: list
        list of file paths to ask for
    
    RETURNS:
    ------------------------------
    bool
        True if the user wants to override the files, False otherwise
    """

    for file_path in file_paths:
        file_exists = False
        if os.path.exists(file_path):
            file_exists = True
            break
    
    if file_exists:
        while True:
            print("At least one of the following files already exists:")
            print(file_paths)
            answer = input("\nDo you want to override all of them? (y/n): ")
            if answer == "y":
                for file_path in file_paths:
                    if os.path.exists(file_path):
                        os.remove(file_path)
                return "y"
            elif answer == "n":
                return "n"
            else:
                print("Please enter 'y' or 'n'.")